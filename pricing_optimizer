from typing import List, Dict, Tuple
import itertools
import time
import random
import argparse
import numpy as np
from functools import lru_cache

class RidePricingOptimizer:
    def __init__(self, demand_model="quadratic"):
        self.cost_per_ride = 3.0
        self.price_min = self.cost_per_ride  # Available price points
        self.price_max = 30.0
        self.price_options = [15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]  # Available price points
        self.demand_model = demand_model

    def optimize_prices_discrete(self, base_demands, max_drivers_per_period=None):
        """
        Uses dynamic programming to optimize pricing by finding an optimal path of prices; uses recursion to find optimal
        path for rest-of-day given price, calculates total profit, and then compares to each other price in list.
        
        Args:
            base_demands: Expected number of ride requests for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
            max_drivers_per_period (optional): Expected number of drivers available for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
        
        Returns:
            List of optimal prices for each period
            Example: [8, 12, 15, 10, 7] 
        
        """

        num_periods = len(base_demands)

        # cehck for errors in input
        if (max_drivers_per_period is not None) and (len(max_drivers_per_period) < num_periods):
            raise ValueError("max_drivers must have the same length as base_demands (or longer)")

        # dynamic programming algorithm for price optimization
        @lru_cache(maxsize=None) # memoization with lru_cache
        def look_ahead(period, deferred_customers):
            optimal_prices = ()
            optimal_profit = float("-inf")

            total_demand = base_demands[period] + deferred_customers

            for price in self.price_options:
                # calculate profit for this period

                if max_drivers_per_period is not None:
                    supply = max_drivers_per_period[period]
                    actual_customers, new_deferred, _ = self.calculate_demand_and_spillover(total_demand, price, supply)
                    period_profit = (price - self.cost_per_ride) * actual_customers

                else:
                    actual_customers, new_deferred, _ = self.calculate_demand_and_spillover(total_demand, price)
                    period_profit = (price - self.cost_per_ride) * actual_customers
                
                # check if there are future periods
                if period + 1 < num_periods:
                    # calculate future profits
                    future_profit, future_prices = look_ahead(period + 1, new_deferred)
                else:
                    # no future profits for end-of-day
                    future_profit = 0 # change for spillover?
                    future_prices = ()

                #  calculate total profit
                total_profit = period_profit + future_profit

                # check if we have a new optimal solution
                if total_profit > optimal_profit:
                    optimal_profit = total_profit
                    optimal_prices = (price,) + future_prices
            
            return(optimal_profit, optimal_prices)
        
        profit, prices = look_ahead(0,0)
        price_list = list(prices)
        return price_list
    
    def optimize_prices_continuous(self, base_demands, max_drivers_per_period=None, start_prices=None):
        """
        Uses gradient ascent with Armijo backtracking to optimie prices by moving 
        prices for each period in the directions that maximize profit.

        Args:
            base_demands: Expected number of ride requests for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
            max_drivers_per_period (optional): Expected number of drivers available for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
            start_prices (optional): Starting point for gradient descent algorithm 
                         If not provided, initialized at the mean of self.price_min and self.price_max
                         Example: [17.0, 13.0, 12.0, 11.0, 10.0] for 5 periods
        
        Returns:
            List of optimal prices for each period
            Example: [8, 12, 15, 10, 7] 
        """
        step_size=1e-3          # step_size for gradient 
        max_iters=200 
        c1=1e-4                 # armijo parameter for "good enough" increase
        backtrack=0.5           # shrink factor for alpha iterations
        tol_g=1e-6              # tolerance for gradient norm
        tol_f=1e-8              # tolerance for profit improvement

        num_periods = len(base_demands)

        # check for errors in inputs
        if start_prices is None:
            start_prices = np.full(num_periods, 0.5 * (self.price_min + self.price_max))
        elif (len(start_prices) < num_periods):
            raise ValueError("start_prices must have the same length as base_demands (or longer)")
        if (max_drivers_per_period is not None) and (len(max_drivers_per_period) < num_periods):
            raise ValueError("max_drivers must have the same length as base_demands (or longer)")

        # starting point
        prices = start_prices
        # helper to project into range
        def project(z):
            return np.clip(z, self.price_min, self.price_max)

        # evaluate once
        start_profit = self.simulate_day(base_demands, prices, max_drivers_per_period)

        for iter in range(max_iters):
            # linear gradient calculation
            price_gradient = np.zeros(num_periods, dtype=float)
            for i in range(num_periods):
                step = max(1e-4, abs(prices[i])*1e-6, step_size)
                iter_vector = np.zeros(num_periods); iter_vector[i] = 1.0
                forward = self.simulate_day(base_demands, project(prices + step*iter_vector), max_drivers_per_period)
                backward = self.simulate_day(base_demands, project(prices - step*iter_vector), max_drivers_per_period)
                price_gradient[i] = (forward - backward) / (2.0*step)
            
            norm = np.linalg.norm(price_gradient, ord=2)
            if norm < tol_g:
                break

            # projected gradient direction
            price_gradient_normalized = price_gradient / (norm + 1e-16)

            # if at a bound and pushing outward, zero that component
            for i in range(num_periods):
                if (prices[i] <= self.price_min + 1e-12 and price_gradient_normalized[i] < 0) or \
                 (prices[i] >= self.price_max - 1e-12 and price_gradient_normalized[i] > 0):
                    price_gradient_normalized[i] = 0.0

            if np.allclose(price_gradient_normalized, 0.0):
                break

            # Armijo gradient ascent
            alpha = 1.0
            rhs_slope = c1 * norm  # because gradient is normalized, gradient^T * norm = ||gradient||
            improved = False
            while alpha > 1e-12:
                prices_alpha = project(prices + alpha * price_gradient_normalized)
                profit_new = self.simulate_day(base_demands, prices_alpha, max_drivers_per_period)
                if profit_new >= start_profit + alpha * rhs_slope:
                    improved = True
                    break
                alpha *= backtrack

            if not improved:
                # could not find an improving step, stop
                break

            # accept
            rel_gain = (profit_new - start_profit) / max(1.0, abs(start_profit))
            prices, start_profit = prices_alpha, profit_new
            if rel_gain < tol_f:
                break

        return prices
    
    def optimize_prices_continuous_quadratic(self, base_demands, max_drivers_per_period=None, start_prices=None, step_size=0.1):
        """"
        Uses gradient descent with quardtic interpolation to optimie prices by moving 
        prices for each period in the directions that maximize profit.

        Args:
            base_demands: Expected number of ride requests for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
            max_drivers_per_period (optional): Expected number of drivers available for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
            start_price (optional): Starting point for gradient descent algorithm 
                         If not provided, initialized at the mean of self.price_min and self.price_max
                         Example: 17.0
        
        Returns:
            List of optimal prices for each period
            Example: [8, 12, 15, 10, 7] 
        """
        

        num_periods = len(base_demands)

        # check for errors in inputs
        if start_prices is None:
            start_prices = np.full(num_periods, 0.5 * (self.price_min + self.price_max))
        elif (len(start_prices) < num_periods):
            raise ValueError("start_prices must have the same length as base_demands (or longer)")
        if (max_drivers_per_period is not None) and (len(max_drivers_per_period) < num_periods):
            raise ValueError("max_drivers must have the same length as base_demands (or longer)")

        # parameters & starting guess
        err_1 = 0.00001                    # tolerance for alpha values
        err_2 = 0.00001                    # tolerance for delta(profit)
        
        prices = start_prices
        iterations = 100

        
        # iterate up to max iterations or optimum reached
        for iter in range (1, iterations):
                
            price_gradient = np.full(num_periods, 0, dtype=float)
            profit = self.simulate_day(base_demands, prices, max_drivers_per_period)

            # calculate price gradient
            new_prices = prices.copy()
            for period in range (0, num_periods):
                new_prices[period] = new_prices[period] + step_size
                new_profit = self.simulate_day(base_demands, new_prices, max_drivers_per_period)
                price_gradient[period] = (new_profit - profit)/step_size
                new_prices = prices.copy()
                
            # calculate norm of gradient (so we can normalize)
            price_gradient_norm = 0
            for period in range(0,num_periods):
                price_gradient_norm += price_gradient[period] ** 2
            price_gradient_norm = price_gradient_norm ** 0.5

            if price_gradient_norm < err_1:
                return prices
            
            for period in range(0, num_periods):
                price_gradient[period] = price_gradient[period] / (price_gradient_norm) # normalize
            
            # now we find a nice alpha to multiply the gradient by! this uses quadrtic interpolation
            alpha_1 = 0
            profit_1 = profit
            alpha_3 = 1
            profit_3 = self.simulate_day(base_demands, prices + alpha_3 * price_gradient, max_drivers_per_period)

            while profit_1 - err_2 >= profit_3:
                alpha_3 = alpha_3 / 2
                profit_3 = self.simulate_day(base_demands, prices + (price_gradient * alpha_3), max_drivers_per_period)
                if alpha_3 < err_1:
                    return prices
                
            alpha_2 = alpha_3 / 2
            profit_2 = self.simulate_day(base_demands, prices + (price_gradient * alpha_2), max_drivers_per_period)

            coeff_1 = (profit_2 - profit_1) / alpha_2
            coeff_2 = (profit_3 - profit_2) / (alpha_3 - alpha_2)
            coeff_3 = (coeff_2 - coeff_1) / alpha_3

            if coeff_3 != 0:
                alpha_0 = 0.5 * (alpha_2 - coeff_1 / coeff_3)
                profit_0 = self.simulate_day(base_demands, prices + (price_gradient * alpha_0), max_drivers_per_period)
            else: 
                profit_0 = profit_3 - 1

            if profit_0 >= profit_3:
                new_profit = profit_0
                new_prices = prices + (price_gradient * alpha_0)
            else:
                new_profit = profit_3
                new_prices = prices + (price_gradient * alpha_3)

            # cap prices
            for period in range (0, num_periods):
                if new_prices[period] > self.price_max:
                    new_prices[period] = self.price_max
                elif new_prices[period] < self.price_min:
                    new_prices[period] = self.price_min

            new_profit = self.simulate_day(base_demands, new_prices, max_drivers_per_period)

            if new_profit > profit + err_2:
                profit = new_profit
                prices = new_prices
                print("iterate success")
            else:
                return prices
            
        return(prices)
    
    def optimize_prices_cluster(self, base_demands, max_drivers_per_period=None, num_tests=10):
        """
        Helps find optimal solution via gradient decsent by running gradient descent from various starting price cases.
        Depends on optimize_prices_continuous.

        Args:
            base_demands: Expected number of ride requests for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
            max_drivers_per_period (optional): Expected number of drivers available for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
            nut_tests (optional): Number of evenly-spaced test points as the start for the gradient descent
                            algorithm; default is 10
        
        Returns:
            List of optimal prices for each period
            Example: [8, 12, 15, 10, 7] 
        
        """
        num_periods = len(base_demands)

        # check for errors in inputs
        if (max_drivers_per_period is not None) and (len(max_drivers_per_period) < num_periods):
            raise ValueError("max_drivers must have the same length as base_demands (or longer)")


        # get a list of evently-spaced price points to start at
        start_prices = np.linspace(self.price_min, self.price_max, num_tests)

        # initialize optimal values to maximize against
        profit_opt = float("-inf")
        prices_opt = []
        
        # run gradient descent for each starting point
        for start_price in start_prices:
            start_price_vec = np.full(num_periods, start_price)
            prices = self.optimize_prices_continuous(base_demands, max_drivers_per_period, start_price_vec)
            profit = self.simulate_day(base_demands, prices, max_drivers_per_period)
            if profit > profit_opt:
                profit_opt = profit
                prices_opt = prices

        # return optimal prices
        return prices_opt
    
    def optimize_prices_combination(self, base_demands, max_drivers_per_period=None):
        """
        Optimizes prices by finding the best discrete possibility and then optimizing from there via gradient descent.
        Depends on the optimize_prices_discrete and optimize_prices_continuous functions.

        Args:
            base_demands: Expected number of ride requests for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
            max_drivers_per_period (optional): Expected number of drivers available for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
        
        Returns:
            List of optimal prices for each period
            Example: [8, 12, 15, 10, 7] 
        
        """
        num_periods = len(base_demands)

        # check for errors in inputs
        if (max_drivers_per_period is not None) and (len(max_drivers_per_period) < num_periods):
            raise ValueError("max_drivers must have the same length as base_demands (or longer)")

        # start with optimal discrete prices and iterate better
        start_prices = self.optimize_prices_discrete(base_demands, max_drivers_per_period)
        better_prices = self.optimize_prices_continuous(base_demands, max_drivers_per_period, start_prices)

        # check if we got better (i hope so!), otherwise return discrete prices as a best-case
        if self.simulate_day(base_demands, better_prices, max_drivers_per_period) > self.simulate_day(base_demands, start_prices, max_drivers_per_period):
            return better_prices
        else:
            return start_prices



    def simulate_day(self, base_demands, prices, max_drivers_per_period=None):
        """
        Simulate one full day with the given prices and return total profit.
        Make sure to handle spillover effects and demand calculations.
        Use this to evaluate your pricing strategy.
        
        Args:
            base_demands: Base demand for each period
            max_drivers_per_period: Expected number of drivers available for each time period
            prices: Price in each period
            
        Returns:
            Total profit for the day
        """
        if len(base_demands) != len(prices):
            raise ValueError("base_demands and prices must have same length")
        if max_drivers_per_period is not None: 
            if len(prices) > len(max_drivers_per_period):
                raise ValueError("max_drivers must have the same length as prices (or longer!)")
        
        total_profit = 0
        deferred_customers = 0  # Number of spillover customers
        lost_customers = 0 # Number of customers choosing other services (not spillover)
        
        for period in range(len(base_demands)):
            # Total demand = base demand + spillover
            total_demand = base_demands[period] + deferred_customers
            if max_drivers_per_period is not None:
                supply = max_drivers_per_period[period]
            else:
                supply = None
            
            actual_customers, new_deferred, new_lost = self.calculate_demand_and_spillover(
                total_demand, prices[period], supply
            )
            
            # Calculate profit for this period
            period_profit = (float(prices[period]) - self.cost_per_ride) * actual_customers
            total_profit += period_profit
            
            # Update spillover customers for next period
            deferred_customers = new_deferred
            lost_customers += new_lost
       
        return total_profit

    def calculate_demand_and_spillover(self, total_demand, price, max_drivers=None):
        """
        Returns (actual_customers, deferred_to_next, lost_customers)
        Applies the model in self.demand_model, then caps by supply if provided.
        """

        supply = max_drivers if max_drivers is not None else None

        # --- Demand model selection ---
        if self.demand_model == "quadratic":
            # Smooth deferral; no "lost" unless capacity binds.
            proportion_deferred = min(max(price ** 2 / 900.0, 0.0), 1.0)
            deferred = proportion_deferred * total_demand
            lost = 0.0
            demand = total_demand - deferred
        
        elif self.demand_model == "linear":
            # Smooth deferral; no "lost" unless capacity binds.
            proportion_deferred = min(max(price / 30.0, 0.0), 1.0)
            deferred = proportion_deferred * total_demand
            lost = 0.0
            demand = total_demand - deferred

        elif self.demand_model == "tiered50":
            # 100% ride â‰¤10; mid-tier deferral+lost; high-tier more severe.
            if price <= 10:
                demand, deferred, lost = total_demand, 0.0, 0.0
            elif price <= 20:
                deferred = total_demand * 0.20
                lost     = total_demand * 0.30
                demand   = total_demand - deferred - lost
            else:
                deferred = total_demand * 0.30
                lost     = total_demand * 0.70
                demand   = total_demand - deferred - lost

        elif self.demand_model == "tieredSoft":
            # Softer penalties in mid/high tiers, no explicit lost component.
            if price <= 10:
                demand, deferred, lost = total_demand, 0.0, 0.0
            elif price <= 20:
                deferred = total_demand * 0.10
                lost     = 0.0
                demand   = total_demand - deferred
            else:
                deferred = total_demand * 0.30
                lost     = 0.0
                demand   = total_demand - deferred

        else:
            raise ValueError(f"Unknown demand_model: {self.demand_model}")

        # --- Capacity cap & recompute deferral if we hit supply ---
        if supply is not None:
            if demand >= supply:
                actual = float(supply)
                # Anything not served becomes deferred unless explicitly lost already
                # We treat unserved portion of (demand) as additional deferral.
                # Keep prior 'lost' from model.
                # Remaining demand beyond supply gets deferred to next period.
                additional_deferred = max(demand - actual, 0.0)
                deferred = deferred + additional_deferred
            else:
                actual = float(demand)
        else:
            actual = float(demand)

        return float(actual), float(deferred), float(lost)

# Sample usage and testing
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Run RidePricingOptimizer scenarios.")
    parser.add_argument("--model", type=str, default="tieredSoft",
                        choices=["quadratic", "linear", "tiered50", "tieredSoft"],
                        help="Demand/deferral model to use.")
    parser.add_argument("--tests", type=int, default=20, help="Num seeds for cluster search.")
    args = parser.parse_args()

    def run_scenario(name, base_demands, max_drivers=None):
        opt = RidePricingOptimizer(demand_model=args.model)

        def pr(label, prices):
            prof = opt.simulate_day(base_demands, prices, max_drivers)
            print(f"{label:>10}: {prices} -> Profit ${prof:.2f}")

        print(f"\n=== Scenario: {name} | model={args.model} ===")
        dp = opt.optimize_prices_discrete(base_demands, max_drivers)
        pr("DP", dp)

        gd = opt.optimize_prices_continuous(base_demands, max_drivers)
        pr("GD", gd)

        cl = opt.optimize_prices_cluster(base_demands, max_drivers, num_tests=args.tests)
        pr("Cluster", cl)

        combo = opt.optimize_prices_combination(base_demands, max_drivers)
        pr("Combo", combo)

    # Example scenarios (expand as needed)
    run_scenario("Mixed day (with capacity)",
                 base_demands=[100, 35, 50, 75],
                 max_drivers=[55, 40, 50, 80])

    run_scenario("Mixed day (no capacity)",
                 base_demands=[100, 35, 50, 75],
                 max_drivers=None)
