from typing import List, Dict, Tuple
import itertools
import time
import random
import numpy as np

class RidePricingOptimizer:
    def __init__(self):
        self.cost_per_ride = 3.0
        self.price_min = self.cost_per_ride  # Available price points
        self.price_max = 30.0
        self.price_options = [15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]  # Available price points

    def optimize_prices_discrete(self, base_demands, max_drivers_per_period=None):
        """
        Uses dynamic programming to optimize pricing by finding an optimal path of prices; uses recursion to find optimal
        path for rest-of-day given price, calculates total profit, and then compares to each other price in list.
        
        Args:
            base_demands: Expected number of ride requests for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
            max_drivers_per_period (optional): Expected number of drivers available for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
        
        Returns:
            List of optimal prices for each period
            Example: [8, 12, 15, 10, 7] 
        
        """

        num_periods = len(base_demands)

        if (max_drivers_per_period is not None) and (len(max_drivers_per_period) != num_periods):
            raise ValueError("max_drivers and base_demands must have same length")

        # dynamic programming algorithm for price optimization
        def look_ahead(period, deferred_customers):
            optimal_prices = []
            optimal_profit = float("-inf")

            total_demand = base_demands[period] + deferred_customers

            for price in self.price_options:
                # calculate profit for this period

                if max_drivers_per_period is not None:
                    supply = max_drivers_per_period[period]
                    actual_customers, new_deferred = self.calculate_demand_and_spillover(total_demand, price, supply)
                    period_profit = (price - self.cost_per_ride) * actual_customers

                else:
                    actual_customers, new_deferred = self.calculate_demand_and_spillover(total_demand, price)
                    period_profit = (price - self.cost_per_ride) * actual_customers
                
                # check if there are future periods
                if period + 1 < num_periods:
                    # calculate future profits
                    future_profit, future_prices = look_ahead(period + 1, new_deferred)
                else:
                    # no future profits for end-of-day
                    future_profit = 0 # change for spillover?
                    future_prices = []

                #  calculate total profit
                total_profit = period_profit + future_profit

                # check if we have a new optimal solution
                if total_profit > optimal_profit:
                    optimal_profit = total_profit
                    optimal_prices = [price] + future_prices
            
            return(optimal_profit, optimal_prices)
        
        profit, prices = look_ahead(0,0)
        return prices
        
    def optimize_prices_continuous(self, base_demands, max_drivers_per_period=None, start_price=None, step_size=0.1):
        """
        Uses gradient decsent to optimie prices by moving prices for each period in the directions that maximize profit.

        Args:
            base_demands: Expected number of ride requests for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
            max_drivers_per_period (optional): Expected number of drivers available for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
            start_price (optional): Starting point for gradient descent algorithm 
                         If not provided, initialized at the mean of self.price_min and self.price_max
                         Example: 17.0
        
        Returns:
            List of optimal prices for each period
            Example: [8, 12, 15, 10, 7] 
        
        """

        num_periods = len(base_demands)

        # parameters
        err_1 = 0.00001                    # tolerance for alpha values
        err_2 = 0.05                       # tolerance for delta(profit)
        if start_price is None:
            start_price = (self.price_min + self.price_max) * 0.5
        iterations = 500
            
        # starting guess
        prices = np.full(num_periods, start_price, dtype = float)
        #period_profits = np.full(num_periods, 0.0, dtype = float)
        

        # iterate up to max iterations or optimum reached
        for iter in range (1, iterations):
                
            price_gradient = np.full(num_periods, 0, dtype=float)
            profit = self.simulate_day(base_demands, prices, max_drivers_per_period)

            # calculate price gradient
            new_prices = prices.copy()
            for period in range (0, num_periods):
                new_prices[period] = new_prices[period] + step_size
                new_profit = self.simulate_day(base_demands, new_prices, max_drivers_per_period)
                price_gradient[period] = (new_profit - profit)/step_size
                new_prices = prices.copy()
                
            # calculate norm of gradient (so we can normalize)
            price_gradient_norm = 0
            for period in range(0,num_periods):
                price_gradient_norm += price_gradient[period] ** 2
            price_gradient_norm = price_gradient_norm ** 0.5

            if price_gradient_norm < err_1:
                return prices
            
            for period in range(0, num_periods):
                price_gradient[period] = price_gradient[period] / (price_gradient_norm) # normalize
            
            # now we find a nice alpha to multiply the gradient by!
            alpha_1 = 0
            profit_1 = profit
            alpha_3 = 1
            profit_3 = self.simulate_day(base_demands, prices + alpha_3 * price_gradient, max_drivers_per_period)

            while profit_1 - err_2 >= profit_3:
                alpha_3 = alpha_3 / 2
                profit_3 = self.simulate_day(base_demands, prices + (price_gradient * alpha_3), max_drivers_per_period)
                if alpha_3 < err_1:
                    # print("no improvement") # debugging statement
                    return prices
                
            alpha_2 = alpha_3 / 2
            profit_2 = self.simulate_day(base_demands, prices + (price_gradient * alpha_2), max_drivers_per_period)

            coeff_1 = (profit_2 - profit_1) / alpha_2
            coeff_2 = (profit_3 - profit_2) / (alpha_3 - alpha_2)
            coeff_3 = (coeff_2 - coeff_1) / alpha_3

            if coeff_3 != 0:
                alpha_0 = 0.5 * (alpha_2 - coeff_1 / coeff_3)
                profit_0 = self.simulate_day(base_demands, prices + (price_gradient * alpha_0), max_drivers_per_period)
            else: 
                profit_0 = profit_3 - 1

            if profit_0 >= profit_3:
                new_profit = profit_0
                new_prices = prices + (price_gradient * alpha_0)
            else:
                new_profit = profit_3
                new_prices = prices + price_gradient

            # cap prices
            for period in range (0, num_periods):
                if new_prices[period] > self.price_max:
                    new_prices[period] = self.price_max
                elif new_prices[period] < self.price_min:
                    new_prices[period] = self.price_min

            new_profit = self.simulate_day(base_demands, new_prices, max_drivers_per_period)

            if new_profit > profit + err_2:
                profit = new_profit
                prices = new_prices
                # print("iterate success")
            else:
                return prices
            
        # print("max iterations") # debugging statement
        return(prices)
    
    def optimize_prices_cluster(self, base_demands, max_drivers_per_period=None, num_tests=10):
        """
        Helps find optimal solution via gradient decsent by running gradient descent from various starting price cases.
        Depends on optimize_prices_continuous.

        Args:
            base_demands: Expected number of ride requests for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
            max_drivers_per_period (optional): Expected number of drivers available for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
            nut_tests (optional): Number of evenly-spaced test points as the start for the gradient descent
                            algorithm; default is 10
        
        Returns:
            List of optimal prices for each period
            Example: [8, 12, 15, 10, 7] 
        
        """
        # get a list of evently-spaced price points to start at
        start_prices = np.linspace(self.price_min, self.price_max, num_tests)

        # initialize optimal values to maximize against
        profit_opt = float("-inf")
        prices_opt = []
        
        # run gradient descent for each starting point
        for start_price in start_prices:
            prices = self.optimize_prices_continuous(base_demands, max_drivers_per_period, start_price)
            profit = self.simulate_day(base_demands, prices, max_drivers_per_period)
            if profit > profit_opt:
                profit_opt = profit
                prices_opt = prices

        # return optimal prices
        return prices_opt
    
    def optimize_prices_combination(self, base_demands, max_drivers_per_period=None):
        """
        Optimizes prices by finding the best discrete possibility and then optimizing from there via gradient descent.
        Depends on the optimize_prices_discrete and optimize_prices_continuous functions.

        Args:
            base_demands: Expected number of ride requests for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
            max_drivers_per_period (optional): Expected number of drivers available for each time period
                         Example: [20, 50, 80, 60, 40] for 5 periods
        
        Returns:
            List of optimal prices for each period
            Example: [8, 12, 15, 10, 7] 
        
        """
        # start with optimal discrete prices and iterate better
        start_prices = self.optimize_prices_discrete(base_demands, max_drivers_per_period)
        better_prices = self.optimize_prices_continuous(base_demands, max_drivers_per_period, start_prices, 0.01)

        # check if we got better (i hope so!), otherwise return discrete prices as a best-case
        if self.simulate_day(base_demands, better_prices, max_drivers_per_period) > self.simulate_day(base_demands, start_prices, max_drivers_per_period):
            return better_prices
        else:
            return start_prices



    def simulate_day(self, base_demands, prices, max_drivers_per_period=None):
        """
        Simulate one full day with the given prices and return total profit.
        Make sure to handle spillover effects and demand calculations.
        Use this to evaluate your pricing strategy.
        
        Args:
            base_demands: Base demand for each period
            max_drivers_per_period: Expected number of drivers available for each time period
            prices: Price in each period
            
        Returns:
            Total profit for the day
        """
        if len(base_demands) != len(prices):
            raise ValueError("base_demands and prices must have same length")
        if max_drivers_per_period is not None: 
            if len(prices) != len(max_drivers_per_period):
                raise ValueError("max_drivers and prices must have same length")
        
        total_profit = 0
        deferred_customers = 0  # Number of spillover customers
        
        for period in range(len(base_demands)):
            # Total demand = base demand + spillover
            total_demand = base_demands[period] + deferred_customers
            if max_drivers_per_period is not None:
                supply = max_drivers_per_period[period]
            else:
                supply = None
            
            actual_customers, new_deferred = self.calculate_demand_and_spillover(
                total_demand, prices[period], supply
            )
            
            # Calculate profit for this period
            period_profit = (float(prices[period]) - self.cost_per_ride) * actual_customers
            total_profit += period_profit
            
            # Update spillover customers for next period
            deferred_customers = new_deferred
       
        return total_profit

    def calculate_demand_and_spillover(self, total_demand, price, max_drivers=None):
        """
        Calculate actual ridership and spillover based on price.
        - quadratic model; 100% of riders ride when price is 0, 0% ride when price is $30
        
        Args:
            total_demand: Total customers wanting rides this period
            max_drivers: number of drivers available this period
            price: Price being charged
            
        Returns:
            (actual_customers_this_period, customers_deferred_to_next_period)
        """
        
        
        if max_drivers is not None:
            supply = max_drivers
        else:
            supply = None
        
        """
        # quadratic deferral model for testing

        proportion_deferred = min((price ** 2) / 900, 1)
        deferred = proportion_deferred * total_demand
        demand = total_demand - deferred
        """
        
        """
        # original price strategy

        if price <= 10:
            demand = total_demand
            deferred = 0
        elif price <= 20:
            deferred = int(total_demand * 0.1)
            demand = total_demand - deferred
        else:  # price >= 21:
            deferred = int(total_demand * 0.3)
            demand = total_demand - deferred
        """


        
        # strategy to test

        if price <= 10:
            demand = total_demand
            deferred = 0
        elif price <= 20:
            deferred = int(total_demand * 0.5)
            demand = total_demand - deferred
        else:  # price >= 21:
            deferred = int(total_demand * 1)
            demand = total_demand - deferred
        

        if supply is not None:
            if demand >= supply:
                actual = supply
                deferred = total_demand - actual
            else:
                actual = demand
        
        else:
            actual = demand

        return actual, deferred

# Sample usage and testing
if __name__ == "__main__":
    optimizer = RidePricingOptimizer()
    
    # Sample demand pattern: morning, lunch, evening, night
    base_demands = [1000, 35, 50, 250]  # Small example for testing
    max_drivers_per_period = [55, 40, 50, 80] 
    '''
    print(f"Base demands: {base_demands}")
    # print(f"Available prices: {optimizer.price_options}")
    print(f"Cost per ride: ${optimizer.cost_per_ride}\n")

    optimized_prices = optimizer.optimize_prices_continuous(base_demands, max_drivers_per_period)
    print(f"Optimized prices: {optimized_prices}\n")
    profit_opt = optimizer.simulate_day(base_demands, optimized_prices, max_drivers_per_period)
    print(f"Test prices {optimized_prices} -> Profit: ${profit_opt:.2f}\n")

    optimized_prices = optimizer.optimize_prices_continuous(base_demands)
    print(f"Optimized prices: {optimized_prices}\n")
    profit_opt = optimizer.simulate_day(base_demands, optimized_prices)
    print(f"Test prices {optimized_prices} -> Profit: ${profit_opt:.2f}\n")
    '''

    #optimized_prices_better = optimizer.optimize_prices_cluster(base_demands, max_drivers_per_period, int(optimizer.price_max-optimizer.price_min))
    #print(f"Optimized prices (better?): {optimized_prices_better}\n")
    #profit_opt_better = optimizer.simulate_day(base_demands, optimized_prices_better, max_drivers_per_period)
    #print(f"Test prices {optimized_prices_better} -> Profit: ${profit_opt_better:.2f}\n")

    optimized_prices_better = optimizer.optimize_prices_cluster(base_demands, None, int(optimizer.price_max-optimizer.price_min))
    print(f"Optimized prices (better?): {optimized_prices_better}\n")
    profit_opt_better = optimizer.simulate_day(base_demands, optimized_prices_better)
    print(f"Test prices {optimized_prices_better} -> Profit: ${profit_opt_better:.2f}\n")
    
    #optimized_prices_discrete = optimizer.optimize_prices_discrete(base_demands, max_drivers_per_period)
    #print(f"Optimized prices: {optimized_prices_discrete}\n")
    #profit_opt_discrete = optimizer.simulate_day(base_demands, optimized_prices_discrete, max_drivers_per_period)
    #print(f"Test prices {optimized_prices_discrete} -> Profit: ${profit_opt_discrete:.2f}\n")

    optimized_for_real = optimizer.optimize_prices_combination(base_demands)
    p_opt = optimizer.simulate_day(base_demands, optimized_for_real)
    print(f"Test prices {optimized_for_real} -> Profit: ${p_opt:.2f}\n")


    optimized_prices_discrete = optimizer.optimize_prices_discrete(base_demands)
    print(f"Optimized prices: {optimized_prices_discrete}\n")
    profit_opt_discrete = optimizer.simulate_day(base_demands, optimized_prices_discrete)
    print(f"Test prices {optimized_prices_discrete} -> Profit: ${profit_opt_discrete:.2f}\n")


    # Test simulation
    #test_prices = [8, 10, 12, 8]
    #test_profit = optimizer.simulate_day(base_demands, test_prices)
    #print(f"Test prices {test_prices} -> Profit: ${test_profit:.2f}\n")
    
